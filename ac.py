# -*- coding: utf-8 -*-
"""AC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CNEZIYywexAXye3KQTsS0cD8NlgAgl3J
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from itertools import combinations
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.metrics import silhouette_score, davies_bouldin_score, calinski_harabasz_score
from scipy.cluster.hierarchy import linkage, dendrogram
from sklearn.cluster import AgglomerativeClustering
from sklearn.decomposition import PCA

from google.colab import files
uploaded = files.upload()

# Load dataset
file_path = "winequality-red.csv"
df = pd.read_csv(file_path)

# Cek missing values
missing_values = df.isnull().sum()
missing_values = missing_values[missing_values > 0]
if missing_values.empty:
    print("Tidak ada missing values dalam dataset.")
else:
    print("Terdapat missing values:")
    print(missing_values)
    df = df.dropna()

if 'quality' in df.columns:
    y = df['quality'].copy()
    X = df.drop(columns=['quality'])

# Standarisasi fitur numerik
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
print("Data telah distandarisasi untuk analisis klasterisasi.")

# Buat dendrogram untuk menentukan jumlah klaster
plt.figure(figsize=(12, 6))
Z = linkage(X_scaled, method='ward')
dendrogram(Z, truncate_mode="level", p=5)
plt.title("Dendrogram untuk Menentukan Jumlah Klaster")
plt.xlabel("Observasi")
plt.ylabel("Jarak (Dissimilarity)")
plt.show()

# Ambil tinggi penggabungan (dissimilarity)
heights = Z[:, 2]

# Urutkan dari yang terbesar ke terkecil
heights_sorted = np.sort(heights)[::-1]

# Hitung K-Lifetime sebagai perbedaan antar level
k_lifetime = np.diff(heights_sorted)

# Tampilkan hasil untuk K = 2 sampai 6
for k in range(2, 7):
    if k-2 < len(k_lifetime):
        print(f"K = {k}, K-Lifetime = {abs(k_lifetime[k-2]):.2f}")  # Gunakan abs agar positif
    else:
        print(f"K = {k}, K-Lifetime tidak tersedia (data kurang)")

# Buat dendrogram untuk menampilkan K-Lifetime
plt.figure(figsize=(12, 6))
dendrogram(Z, truncate_mode="level", p=5)  # Batasi tingkat pemotongan agar lebih jelas

# Tambahkan garis horizontal untuk menentukan K
max_distance = Z[-(5-1), 2]  # Ambil threshold untuk K=5
plt.axhline(y=max_distance, color='r', linestyle='dashed', label=f'Threshold (K=5)')

# Hitung K-Lifetime
heights = Z[:, 2]  # Ambil tinggi penggabungan
heights_sorted = np.sort(heights)[::-1]  # Urutkan dari tinggi ke rendah
k_lifetime = np.diff(heights_sorted)  # Selisih antar tinggi

# Tampilkan informasi K-Lifetime di dendrogram
for k in range(2, 7):
    if k-2 < len(k_lifetime):
        plt.text(x=0.5, y=heights_sorted[k-2], s=f"K={k}, Lifetime={k_lifetime[k-2]:.2f}",
                 fontsize=10, color='black', backgroundcolor='white')

plt.title("Dendrogram dengan K-Lifetime")
plt.xlabel("Observasi")
plt.ylabel("Jarak (Dissimilarity)")
plt.legend()
plt.show()

# Gunakan jumlah klaster sesuai dendrogram
k = 6
hc = AgglomerativeClustering(n_clusters=k, linkage='ward')

# Fit model dan tambahkan hasil klaster ke dalam dataset
X_pca_df["Cluster"] = hc.fit_predict(X_pca_df)
print(X.head())  # Cek hasil klasterisasi

from sklearn.metrics import silhouette_score, davies_bouldin_score, calinski_harabasz_score,  homogeneity_score, completeness_score, v_measure_score

# Hitung evaluasi klaster
silhouette_avg = silhouette_score(X_scaled, X['Cluster'])
davies_bouldin = davies_bouldin_score(X_scaled, X['Cluster'])
calinski_harabasz = calinski_harabasz_score(X_scaled, X['Cluster'])
homogeneity = homogeneity_score(y.values.ravel(), X['Cluster'])
completeness = completeness_score(y.values.ravel(), X['Cluster'])
v_measure = v_measure_score(y.values.ravel(), X['Cluster'])


# Cetak hasil evaluasi
print(f"Silhouette Score: {silhouette_avg:.4f}")
print(f"Davies-Bouldin Index: {davies_bouldin:.4f}")
print(f"Calinski-Harabasz Index: {calinski_harabasz:.4f}")
print(f"Homogeneity Score: {homogeneity:.4f}")
print(f"Completeness Score: {completeness:.4f}")
print(f"V-Measure Score: {v_measure:.4f}")

#Reduksi Dimensi dengan PCA (2 Komponen)
pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

# Konversi ke DataFrame untuk kemudahan
X_pca_df = pd.DataFrame(X_pca, columns=["PCA1", "PCA2"])

# Klasterisasi dengan K-Means (Gantilah jika ingin menggunakan metode lain)
k = 6  # Tentukan jumlah klaster (bisa berdasarkan dendrogram)
hc = AgglomerativeClustering(n_clusters=k, metric='euclidean', linkage='ward')
labels = hc.fit_predict(X_pca)

# Tambahkan label klaster ke dalam DataFrame
X_pca_df["Cluster"] = labels

# 5. Visualisasi Hasil Klasterisasi dalam 2D
plt.figure(figsize=(8, 6))
sns.scatterplot(x="PCA1", y="PCA2", hue="Cluster", palette="viridis", data=X_pca_df)
plt.xlabel("PCA Component 1")
plt.ylabel("PCA Component 2")
plt.title("Visualisasi Klasterisasi setelah PCA")
plt.legend(title="Cluster")
plt.show()

# Hitung evaluasi klaster hasil PCA
silhouette_avg = silhouette_score(X_pca_df, X_pca_df['Cluster'])
davies_bouldin = davies_bouldin_score(X_pca_df, X_pca_df['Cluster'])
calinski_harabasz = calinski_harabasz_score(X_pca_df, X_pca_df['Cluster'])

# Cetak hasil evaluasi klaster hasil PCA
print(f"Silhouette Score: {silhouette_avg:.4f}")
print(f"Davies-Bouldin Index: {davies_bouldin:.4f}")
print(f"Calinski-Harabasz Index: {calinski_harabasz:.4f}")